'''
문제
연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.

윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.

예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.

입력
첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다.

출력
첫째 줄에 윤년이면 1, 아니면 0을 출력한다.

참고
boolean 값에 + 연산을 하여 정수로 변환할 수 있음 (True 일때 1, False 일때 0 으로 출력)

파이썬에서 세미콜론(;)은 문(statement)의 끝을 나타내는 구분자
세미콜론을 사용하여 한 줄에 여러 개의 문을 작성할 수 있음

(a % 100) or (a // 100) 조건문이 있을때 
첫번째 조건 값이 0 이 아니면 첫번째 조건 값을 사용
첫번째 조건 값이 0 이면 두번째 조건 값을 사용
모든 조건의 값이 0 이면 0 을 사용

dis 모듈을 사용하여 연산 순서 확인 가능
import dis
dis.dis(func)


### 참고 1
2진수의 음수 표현법
https://st-lab.tistory.com/189
1. 부호 절대값
    - 최상위 (가장 왼쪽) 비트가 0이면 양수, 1이면 음수라고 약속
    - +0, -0 둘 다 0으로 인식할 수 있도록 처리 필요
    - 음수가 존재하는 덧셈이나 뺄셈의 경우 MSB와 절대값을 각각 계산해야함
2. 1의 보수
    - n의 보수는 어떤 수에 대해 n의 제곱수가 되도록 만드는 수 (3에 대한 10의 보수는 7, 12에 대한 10의 보수는 88)
    - n진법에서의 (n-1의 보수)는 (n의 보수 - 1) 과 같음 (12에 대한 10의 보수는 88, 9 (10-1) 의 보수는 87 ((100 - 12) - 1))
    - 보수를 사용하는 이유는 음수, 양수 관계없이 덧셈만으로 결과값을 얻을 수 있음
    - -23 + 31 = 음수 23의 보수 + 31 = {(100 - 23) + 31} = 77 + 31 = 108 (23에 대한 10의 보수는 77)
    - 108 = 8 (캐리가 발생하는 경우 양수 / 캐리가 발생한 수는 버림 (예시에서 백의 자리 1))
    - -31 + 23 = 음수 31의 보수 + 23 = {(100 - 31) + 23} = 69 + 23 = 92 (31에 대한 10의 보수 69)
    - 92 = 100 - 92 = 8 = -8 (캐리가 발생하지 않은 경우 음수 / 음수의 경우 보수를 구해서 음수 부호를 붙임)
    - -23 + -31 (둘다 보수가 필요하므로 캐리 여부 2번 확인)
    - {(100 - 23) + (100 - 31)} = 77 + 69 = 146
    - 146 = 46 (캐리가 발생했으므로 백의자리 1 버림)
    - 46 = 100 - 46 (캐리가 발생하지 않았으므로 보수를 구해서 음수 부호를 붙임)
    - 100 - 46 = 54 = -54
    - 보수를 더해서 올림이 발생하면 결과는 양수이고 올림 수는 버림
    - 올림이 발생하지 않으면 결과는 음수이고 계산 결과값의 보수 값이 최종 값이 됨
    - 1의 보수 방식에서 음수는 양수의 비트를 반전시킨 값
    - MSB의 성질이 유지됨
    - 덧셈만으로 뺄셈 구현 가능
    - +0, -0 둘 다 0으로 인식할 수 있도록 처리 필요
    - 캐리 (올림수) 가 발생하는 경우 별도 처리 필요
3. 2의 보수
    - 비트 반전 (1의 보수) 후 +1 해주면 음수값을 얻을 수 있다.
    - MSB의 성질이 유지됨
    - 덧셈만으로 뺄셈 구현 가능
    - 1의 보수의 단점(캐리 발생 문제 및 0이 두 개) 모두 해결됨


### 참고 2
2진수로 음수 표현하는 방법
https://velog.io/@bb5918/%EC%9D%B4%EC%A7%84%EC%88%98%EB%A1%9C-%EC%9D%8C%EC%88%98-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95

2진수로 음수를 표현하는 방법은 2의 보수를 이용하는 방법이 있다.
십진법에서 우리는 8과 -8을 더했을 때 0이 된다는 것을 알고 있다.
2진수에서도 양수로 표현한 2진수와 음수로 표현한 2진수를 합하면 0이 되도록 만들면 된다.

보수
일단 '보수'가 어떤것인지 살펴보자.
6에 대한 10의 보수는 4, 5에 대한 10의 보수는 5이다.
2에 대한 1의 보수는 1이 된다.
보수는 한 마디로 보충을 해주는 수라고 생각을 하면 된다.

1의 보수
1의 보수를 쉽게 구하기 위해서는 0은 1로, 1은 0으로 하면 된다.
그럼 1의 보수를 이용해 -10을 구해보자.
일단 10을 2진수로 표현하면
0000 1010이 된다.
이것을 1의 보수를 취하면
1111 0101이 된다.
둘을 합해보자!
0000 1010 + 1111 0101 = 1111 1111
10과 -10을 더하면 0이 나와야 하는데, 1111 1111이 나와버렸다.
그럼 1의 보수로는 음수를 구할 수는 없다는 결론이 나온다.

2의 보수
음수를 구하는 방법은 2의 보수를 이용하는 방법이다.
2의 보수를 구하는 방법은 1의 보수를 취한 다음에 1을 더해주는 방법이다.
그럼 2의 보수를 이용해 다시 한 번 구해보자.
처음으로 돌아가서 0000 1010 + 1111 0101 + 0000 0001을 하면 1 0000 0000이 된다!
맨 앞에 있는 1은 원래의 범위를 넘어가기 때문에 신경쓰지 않아도 된다.
따라서 0000 1010을 음수로 표현하면 1111 0101 + 0000 0001인 1111 0110이 된다!


### 참고 3
1의 보수에서 양수와 음수의 관계
양의 10진수 (양의 2진수) : 음의 10진수 (음의 2진수)
+0 (0000) : -0 (1111)
+1 (0001) : -1 (1110)
+2 (0010) : -2 (1101)
+3 (0011) : -3 (1100)
0 이 두개가 되므로 2의 보수에서 개선
2의 보수에서 양수와 음수의 관계
+0 (0000) : -1 (1111)
+1 (0001) : -2 (1110)
+2 (0010) : -3 (1101)
+3 (0011) : -4 (1100)
2의 보수에서 1의 보수에 -1 하여 음수 0 을 없앰 (음의 10진수에 해당하는 2진수를 한단계씩 내림)
그리고 계산시 +1 하여 계산 (음의 10진수에 해당하는 2진수를 한단계씩 올림)
최상위 비트에서 캐리 발생시 최상위 비트 버림
중요
1111 은 -0 이 아니고 -1 이다.
음의 10진수와 음의 2진수를 양수와 같게 생각하면 혼돈이 올 수 있다.
양수는 양의 10진수를 그대로 2진수로 표현함
음수 표현시 10진수는 양의 10진수에 -1 한 값으로 생각하고 
2진수는 양의 2진수를 비트 반전시킨 값으로 생각해야함
예시 1)
양수 +0 (0000) : 음수 -1 (1111)
False = 0000 / ~False = 1111
검증 (10진수) : (0) + {(-1) + 1} = (0) + {0} = 0
검증 (2진수) : False + ~False = 0000 + (1111 + 0001) = 0000 + (0001 0000) = 0001 0000 -> 캐리 발생으로 최상위 비트 버림 0000
예시 2)
양수 0001 (+1) : 음수 1110 (-2)
True = 0001 / ~True = 1110
검증 (10진수) : (+1) + {(-2) + 1} = (+1) + {-1} = 0
검증 (2진수) : True + ~True = 0001 + (1110 + 0001) = 0001 + (1111) = 0001 0000 -> 캐리 발생으로 최상위 비트 버림 0000
예시 3)
양수 0011 (+3) : 음수 1100 (-4)
검증 (10진수) : (+3) + {(-4) + 1} = (+3) + {-3} = 0
검증 (2진수) : 0011 + (1100 + 0001) = 0011 + (1101) = 0001 0000 -> 캐리 발생으로 최상위 비트 버림 0000

움의 2진수 구하기
예시 1)
1
0001
-1
1의 보수 = 비트를 뒤집음 = 1110
2의 보수 = 1의 보수에 1을 더해줌 = 1110 + 0001 = 1111
1 + (-1) = 0001 + 1111 = 0001 0000 : 위에서 최대 4비트를 사용하였으므로 4비트외에는 버림 (0000 만 확인)
예시 2)
3
0011
-3
1의 보수 = 비트를 뒤집음 = 1100
2의 보수 = 1의 보수에 1을 더해줌 = 1100 + 0001 = 1101
3 + (-3) = 0011 + 1101 = 0001 0000 : 위에서 최대 4비트를 사용하였으므로 4비트외에는 버림 (0000 만 확인)
예시 3)
10
1010
-10
1의 보수 = 비트를 뒤집음 = 0101
2의 보수 = 1의 보수에 1을 더해줌 = 0101 + 0001 = 0110
10 + (-10) = 1010 + 0110 = 0001 0000 : 위에서 최대 4비트를 사용하였으므로 4비트외에는 버림 (0000 만 확인)

2의 제곱근 하위 비트를 모두 합산한 값은 (2의 제곱근 - 1) 과 같다.
예시 1)
0100 = 4
0011 = 2 + 1 = 3 = 4 - 1
예시 2)
0001 0000 = 16
0000 1111 = 8 + 4 + 2 + 1 = 15 = 16 - 1
예시 3)
0010 0000 0000 = 512
0001 1111 1111 = 256 + 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 511 = 512 - 1

2의 보수 방식으로 된 2진수를 10진수로 변환하는 빠른 계산법
최상위 비트가 1 이면 최상위 비트만 음수 처리하여 합산
예시 1)
1010 = -8 + 2 = -6
검증 = 비트 반전 + 0001 = 0101 + 0001 = 0110 = 6 = 음수 부호 붙임 = -6
예시 2)
1110 0001 = -128 + 64 + 32 + 1 = -31
검증 = 비트 반전 + 0001 = 0001 1110 + 0001 = 0001 1111 = 16 + 15 = 31 = 음수 부호 붙임 = -31


### 참고 4
비트 연산자중 1개의 수만 가지고 연산하는것을 단항 연산자, 2개의 수로 연산하는것을 이항 연산자라 함
비트 연산자 >> (오른쪽 시프트), << (왼쪽 시프트) 연산
>> (오른쪽 시프트)
x >> n : 비트를 오른쪽으로 n 만큼 이동한다.
2진수는 2의 제곱근이므로 자릿수가 줄어들때마다 1/2씩 작아짐 (8, 4, 2)
(10진수는 10의 제곱근이므로 자릿수가 줄어들때마다 1/10씩 작아짐 (1000, 100, 10))
예시)
3 >> 1 = 0000 0011 >> 1 = 0000 0001 = 1
3 >> 2 = 0000 0011 >> 2 = 0000 0000 = 0
8 >> 1 = 0000 1000 >> 1 = 0000 0100 = 4
8 >> 2 = 0000 1000 >> 2 = 0000 0010 = 2
10 >> 1 = 0000 1010 >> 1 = 0000 0101 = 5
10 >> 2 = 0000 1010 >> 2 = 0000 0010 = 2

<< (왼쪽 시프트)
x << n : 비트를 왼쪽으로 n 만큼 이동한다.
2진수는 2의 제곱근이므로 자릿수가 늘어날때마다 2배씩 커짐 (2, 4, 8)
(10진수는 10의 제곱근이므로 자릿수가 늘어날때마다 10배씩 커짐 (10, 100, 1000))
예시)
3 << 1 = 0000 0011 << 1 = 0000 0110 = 6
3 << 2 = 0000 0011 << 2 = 0000 1100 = 12
8 << 1 = 0000 1000 << 1 = 0001 0000 = 16
8 << 2 = 0000 1000 << 2 = 0010 0000 = 32
10 << 1 = 0000 1010 << 1 = 0001 0100 = 20
10 << 2 = 0000 1010 << 2 = 0010 1000 = 40


### 참고 5
비트 연산자 & (AND, 논리곱) 연산은 두개의 2진수에서 동일한 위치의 bit 를 곱한다.
결국 두개의 2진수에서 동일한 위치의 bit 가 1인 것들만 1로 계산, 그 외는 0

2진수를 구하기위한 2의 배수
256 128 64 32 16 8 4 2 1
2의 제곱수 비트 배열은 항상 1이 하나만 존재함
10진수 = 2진수
1 = 0001
2 = 0010
4 = 0100
8 = 1000
16 = 0001 0000
32 = 0010 0000
64 = 0100 0000
128 = 1000 0000
256 = 0001 0000 0000

n & -n 연산은 이진 표현에서 가장 오른쪽에 있는 1을 남기는 연산
4의 배수가 아닌 수를 & 연산하면 결과값이 1, 2, 1 숫자가 반복된다.
4
0100
-4
1011 + 0001 = 1100
4 & -4 = 0100 & 1100 = 0100
0100 = 4

5
0101
-5
1010 + 0001 = 1011
5 & -5 = 0101 & 1011 = 0001
0001 = 1

6
0110
-6
1001 + 0001 = 1010
6 & -6 = 0110 & 1010 = 0010
0010 = 2

7
0111
-7
1000 + 0001 = 1001
7 & -7 = 0111 & 1001 = 0001
0001 = 1

8
1000
-8
0111 + 0001 = 1000
8 & -8 = 1000 & 1000 = 1000
1000 = 8

2의 제곱근에 대한 배수를 구하는 방법
1 을 버리면 2 의 배수가 되고 ((n & 1) == 0)
2 이하를 버리면 4 의 배수가 되고 ((n & (2 + 1)) == 0)
4 이하를 버리면 8 의 배수가 된다. ((n & (4 + 2 + 1)) == 0)
예시 1) 2의 배수 구하기
1 : ((1 & 1) == 0) = ((0001 & 0001) == 0) = ((0001) == 0) = ((1) == 0) = False
2 : ((2 & 1) == 0) = ((0010 & 0001) == 0) = ((0000) == 0) = ((0) == 0) = True
3 : ((3 & 1) == 0) = ((0011 & 0001) == 0) = ((0001) == 0) = ((1) == 0) = False
4 : ((4 & 1) == 0) = ((0100 & 0001) == 0) = ((0000) == 0) = ((0) == 0) = True
예시 2) 4의 배수 구하기
1 : ((1 & 3) == 0) = ((0001 & 0011) == 0) = ((0001) == 0) = ((1) == 0) = False
2 : ((2 & 3) == 0) = ((0010 & 0011) == 0) = ((0010) == 0) = ((2) == 0) = False
3 : ((3 & 3) == 0) = ((0011 & 0011) == 0) = ((0011) == 0) = ((3) == 0) = False
4 : ((4 & 3) == 0) = ((0100 & 0011) == 0) = ((0000) == 0) = ((0) == 0) = True
7 : ((7 & 3) == 0) = ((0111 & 0011) == 0) = ((0011) == 0) = ((3) == 0) = False
8 : ((8 & 3) == 0) = ((1000 & 0011) == 0) = ((0000) == 0) = ((0) == 0) = True
예시 3) 8의 배수 구하기
1 : ((1 & 7) == 0) = ((0001 & 0111) == 0) = ((0001) == 0) = ((1) == 0) = False
2 : ((2 & 7) == 0) = ((0010 & 0111) == 0) = ((0010) == 0) = ((2) == 0) = False
3 : ((3 & 7) == 0) = ((0011 & 0111) == 0) = ((0011) == 0) = ((3) == 0) = False
4 : ((4 & 7) == 0) = ((0100 & 0111) == 0) = ((0100) == 0) = ((4) == 0) = False
7 : ((7 & 7) == 0) = ((0111 & 0111) == 0) = ((0111) == 0) = ((7) == 0) = False
8 : ((8 & 7) == 0) = ((1000 & 0111) == 0) = ((0000) == 0) = ((0) == 0) = True
18 : ((18 & 7) == 0) = ((0001 0010 & 0111) == 0) = ((0010) == 0) = ((2) == 0) = False
23 : ((23 & 7) == 0) = ((0001 0111 & 0111) == 0) = ((0111) == 0) = ((7) == 0) = False
24 : ((24 & 7) == 0) = ((0001 1000 & 0111) == 0) = ((0000) == 0) = ((0) == 0) = True

하지만 논리 연산자 % (나머지) 연산으로 구하는게 보기에도 직관적이고 코드도 짧다.
게다가 모든 수의 배수를 구할 수 있다.
((n % 2) == 0)
((n % 3) == 0)
((n % 3.25) == 0)
((n % 4) == 0)
((n % 8) == 0)

배열의 경우 반복문을 실행하지않고 비트 연산으로 구분하는 방법???


### 참고 6
비트 연산자 | (OR, 논리합) 연산
피연산자들의 각 비트를 비교하여 하나라도 1인 경우 1로 계산함
동일한 위치의 bit 가 0인 것들만 0으로 계산, 그 외는 1

0 | 0 = 0
0 | 1 = 1
1 | 1 = 1
예시 1)
3 | 8 = 0011 | 1000 = 1011 = 11
예시 2)
12 | 13 = 1100 | 1101 = 1101 = 13
예시 3)
21 | 38 = 0001 0101 | 0010 0110 = 0011 0111 = 32 + 16 + 4 + 2 + 1 = 55
= 최상위 비트 1 의 값이 32 이므로 그보다 상위 비트에 해당하는 2의 제곱근 값은 64 이다.
= 64 하위 비트를 모두 합산했을때 63 이 되어야하므로 아래의 식과 같다.
= 64 - 1 - (하위 비트중 0 인 비트의 값 합계)
= 64 - 1 - (8) = 55


### 참고 7
비트 연산자 ^ (XOR, 베타적 논리합) 연산
피연산자들의 각 비트를 비교하여 서로 다를 경우 1로 계산함
동일한 위치의 bit 가 서로 다르면 1, 같으면 0
1 ^ 2 = 0001 ^ 0010 = 0011 = 3
4 ^ 6 = 0100 ^ 0110 = 0010 = 2


### 참고 8
https://jays-log1111.tistory.com/entry/4-2-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%B9%84%ED%8A%B8%EC%97%B0%EC%82%B0%EC%9E%90-2%EC%9D%98-%EB%B3%B4%EC%88%98-%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0
비트 연산자 ~ (NOT) 연산
비트 단위 부정 (보수(complement)) 연산자로 2진수 값을 반전 시킴
~ 연산자는 모든 비트를 뒤집어주면 됩니다.
~ 연산자 공식은 ~x = -(x + 1)입니다.
예시)
5
0101
~5
1의 보수 = 1010 (최상위 비트가 1이므로 음수)
2의 보수 = 1010 + 0001 = 1011
검증 1 (2진수) : 1011 = (-8) + 2 + 1 = -5
검증 2 (2진수) : 1011 = 비트 반전 + 0001 = 0100 + 0001 = 0101 = 5 = 음수 부호 붙임 = -5
검증 3 (10진수) : 5에 대한 2의 보수는 -6
~x = -(x + 1)
-(5 + 1) = -6
6 = 0110 = 비트 반전 + 0001 = 1001 + 0001 = 1010 (5에 대한 1의 보수)
'''

# 정답 1
# a = int(input())
# if not 1 <= a <= 4000:
#     print('1 ~ 4000 사이의 숫자를 입력하세요.')
#     exit()
# if (a%4 == 0 and a%100 > 0) or a%400 == 0:
#     print('1')
# else:
#     print('0')
    
# 정답 2
# a = int(input())
# if not 1 <= a <= 4000:
#     print('1 ~ 4000 사이의 숫자를 입력하세요.')
#     exit()
# print('1' if (a%4 == 0 and a%100 > 0) or a%400 == 0 else '0')

# 정답 3
# import sys, re
# def change_int(v):
#     v = v.strip()
#     if bool(re.sub("\s", "", v)) == False:
#         return "숫자로 변환할 값이 주어지지않았습니다."
#     if re.search("^-?[0-9]+$", v) is None:
#         return "{} 은(는) 숫자가 아닙니다.".format(v)
#     v = int(v)
#     if v not in range(1, 4001, 1):
#         return "{} 은(는) 수의 범위에 포함되지 않습니다.".format(v)
#     return v
# a = change_int(sys.stdin.readline())
# if not isinstance(a, int):
#     print(a)
#     exit()
# print('1' if (a%4 == 0 and a%100 > 0) or a%400 == 0 else '0')

# 정답 4
# a = int(input())
# print(int((a%4 == 0 and a%100 > 0) or a%400 == 0))

# 정답 5
# n = int(input())
# print(+(
#     (n & -n) > (
#         3 | (
#             8 >> (
#                 n % 50
#                 )
#             )
#         )
#     )
# )

# 정답 6 (정답 5 에서 50 을 100 으로 수정)
n = int(input())
print(+(
    (n & -n) > (
        3 | (
            8 >> (
                n % 100
                )
            )
        )
    )
)

# 정답 7
# n=int(input())
# print(
#     +(
#         (
#             n % (
#                 4 ** (
#                     -(
#                         ~(
#                             (n % 25) < 1
#                         )
#                     )
#                 )
#             )
#         ) < 1
#     )
# )

# 정답 8
# a = int(input()); print(+(a > 0 and ((((a % 100) or (a // 100)) % 4) < 1)))

# 테스트
'''
십집수 = 2진수 = & 연산 = 결과
1 = 0001 = 0001 = 1
2 = 0010 = 0010 = 2
3 = 0011 = 0001 = 1
4 = 0100 = 0100 = 4
5 = 0101 = 0001 = 1
6 = 0110 = 0010 = 2
7 = 0111 = 0001 = 1
8 = 1000 = 1000 = 8
9 = 1001 = 0001 = 1
10 = 1010 = 0010 = 2
11 = 1011 = 0001 = 1
12 = 1100 = 0100 = 4
13 = 1101 = 0001 = 1
14 = 1110 = 0010 = 2
15 = 1111 = 0001 = 1
16 = 0001 0000 = 0001 0000 = 16
17 = 0001 0001 = 0001 = 1
18 = 0001 0010 = 0010 = 2
19 = 0001 0011 = 0001 = 1
20 = 0001 0100 = 0100 = 4
21 = 0001 0101 = 0001 = 1
22 = 0001 0110 = 0010 = 2
23 = 0001 0111 = 0001 = 1
24 = 0001 1000 = 1000 = 8
48 = 0011 0000 = 0001 0000 = 16
49 = 0011 0001 = 0001 = 1
50 = 0011 0010 = 0010 = 2
51 = 0011 0011 = 0001 = 1
52 = 0011 0100 = 0100 = 4
96 = 0110 0000 = 0010 0000 = 32
97 = 0110 0001 = 0001 = 1
98 = 0110 0010 = 0010 = 2
99 = 0110 0011 = 0001 = 1
100 = 0110 0100 = 0100 = 4
400 = 0001 1001 0000 = 0001 0000 = 16
1900 = 0111 0110 1100 = 0100 = 4
2012 = 0111 1101 1100 = 0100 = 4

n&-n = 1, 2 또는 4의 배수 (4년마다 윤년)
3 = n&-n 에서 4미만의 수를 버림
8 = 1000 = 4비트에 1 존재 
= 4비트이상 오른쪽으로 쉬프트하면 0 이됨
= 즉, n%50 의 나머지 수가 4이상이 나오면 n&-n > 3 의 식이 완성됨
3|(8>>(n%50)) 계산 (n&-n 계산은 위 결과 참조)
1 = 3|(8>>(1)) = 3|(4) = 0011+0100 = 0111 = 7 -> 1>7 = False
2 = 3|(8>>(2)) = 3|(2) = 0011+0010 = 0011 = 3 -> 2>3 = False
3 = 3|(8>>(3)) = 3|(1) = 0011+0001 = 0011 = 3 -> 1>3 = False
4 = 3|(8>>(4)) = 3|(0) = 0011+0000 = 0011 = 3 -> 4>3 = True
5 = 3|(8>>(5)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
6 = 3|(8>>(6)) = 3|(0) = 0011+0000 = 0011 = 3 -> 2>3 = False
7 = 3|(8>>(7)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
8 = 3|(8>>(8)) = 3|(0) = 0011+0000 = 0011 = 3 -> 8>3 = True
9 = 3|(8>>(9)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
10 = 3|(8>>(10)) = 3|(0) = 0011+0000 = 0011 = 3 -> 2>3 = False
11 = 3|(8>>(11)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
12 = 3|(8>>(12)) = 3|(0) = 0011+0000 = 0011 = 3 -> 4>3 = True
13 = 3|(8>>(13)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
14 = 3|(8>>(14)) = 3|(0) = 0011+0000 = 0011 = 3 -> 2>3 = False
15 = 3|(8>>(15)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
16 = 3|(8>>(16)) = 3|(0) = 0011+0000 = 0011 = 3 -> 16>3 = True
48 = 3|(8>>(48)) = 3|(0) = 0011+0000 = 0011 = 3 -> 16>3 = True
49 = 3|(8>>(49)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
50 = 3|(8>>(0)) = 3|(8) = 0011+1000 = 1011 = 11 -> 2>11 = False
51 = 3|(8>>(1)) = 3|(4) = 0011+0100 = 0111 = 7 -> 1>7 = False
52 = 3|(8>>(2)) = 3|(2) = 0011+0010 = 0011 = 3 -> 4>3 = True
96 = 3|(8>>(46)) = 3|(0) = 0011+0000 = 0011 = 3 -> 32>3 = True
97 = 3|(8>>(47)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
98 = 3|(8>>(48)) = 3|(0) = 0011+0000 = 0011 = 3 -> 2>3 = False
99 = 3|(8>>(49)) = 3|(0) = 0011+0000 = 0011 = 3 -> 1>3 = False
100 = 3|(8>>(0)) = 3|(8) = 0011+1000 = 1011 = 11 -> 4>11 = False
400 = 3|(8>>(0)) = 3|(8) = 0011+1000 = 1011 = 11 -> 16>11 = True
1900 = 3|(8>>(0)) = 3|(8) = 0011+1000 = 1011 = 11 -> 4>11 = False
2012 = 3|(8>>(12)) = 3|(0) = 0011+0000 = 0011 = 3 -> 4>3 = True
'''
# n = int(input())
# print(+(n&-n>(3|(8>>(n%50)))))
# print(+(n&-n>3|8>>n%50))
# print(n&-n, n&-n>3, bin(n), sep='\n')
# print(n%50, 8>>n%50, sep='\n')
# print(0%50)
# print(+(False|False))
# print(+(True|True))
# print(+(True|False))
# print(+(True|0))
# print(+(True|8))
# print(n%4==0)

# import dis
# def func(n):
#     return +(n&-n>(3|(8>>(n%50))))
#     # return +(n&-n>3|8>>n%50)
# print(dis.dis(func))

# import dis
# def func(n):
#     return +((n%(4**(-(~((n%25)<1)))))<1)
#     # return +(n%4**-~(n%25<1)<1)
# print(dis.dis(func))

'''
True 의 2진수 0000 0001 / 비트 NOT ~True 의 2진수 1111 1110 (부호 있는 8비트 정수로 해석할 때 -2)
False 의 2진수 0000 0000 / 비트 NOT ~False 의 2진수 1111 1111 (부호 있는 8비트 정수로 해석할 때 -1)
(n % 25) < 1 : 나머지가 없으면 True / 있으면 False
~((n % 25) < 1) : 비트 단위 부정 연산자로 2진수 값을 반전 시킴
    True -> ~True (-2) / False -> ~False (-1)
-(~((n % 25) < 1)) : -True = 2 / -False = 1
4 ** -(~((n % 25) < 1)) : 4의 2 제곱 (16) / 4의 1 제곱 (4)
n % (4 ** -(~((n % 25) < 1))) : n 을 16 으로 나눈 나머지 / n 을 4 로 나눈 나머지
(n % (4 ** -(~((n % 25) < 1)))) < 1 : 나머지가 없으면 True / 있으면 False

1 대입
(n % 25) < 1 : False
~((n % 25) < 1) : -1
-(~((n % 25) < 1)) : 1
4 ** -(~((n % 25) < 1)) : 4 ** 1 = 4
n % (4 ** -(~((n % 25) < 1))) : 1 % 4 = 1
(n % (4 ** -(~((n % 25) < 1)))) < 1 : 1 < 1 = False
결과 0

4 대입
(n % 25) < 1 : False
~((n % 25) < 1) : -1
-(~((n % 25) < 1)) : 1
4 ** -(~((n % 25) < 1)) : 4 ** 1 = 4
n % (4 ** -(~((n % 25) < 1))) : 4 % 4 = 0
(n % (4 ** -(~((n % 25) < 1)))) < 1 : 0 < 1 = True
결과 1

100 대입
(n % 25) < 1 : True
~((n % 25) < 1) : -2
-(~((n % 25) < 1)) : 2
4 ** -(~((n % 25) < 1)) : 4 ** 2 = 16
n % (4 ** -(~((n % 25) < 1))) : 100 % 16 = 4
(n % (4 ** -(~((n % 25) < 1)))) < 1 : 4 < 1 = False
결과 0

400 대입
(n % 25) < 1 : True
~((n % 25) < 1) : -2
-(~((n % 25) < 1)) : 2
4 ** -(~((n % 25) < 1)) : 4 ** 2 = 16
n % (4 ** -(~((n % 25) < 1))) : 400 % 16 = 0
(n % (4 ** -(~((n % 25) < 1)))) < 1 : 0 < 1 = True
결과 1
'''
# n=int(input())
# print(
#     +(
#         (
#             n % (
#                 4 ** (
#                     -(
#                         ~(
#                             (n % 25) < 1
#                         )
#                     )
#                 )
#             )
#         ) < 1
#     )
# )


# a = int(input()); print(+(a > 0 and ((((a % 100) or (a // 100)) % 4) < 1)))
# a = 0 을 대입할 경우 윤년으로 판단됨 (오류)
# a = int(input()); print(+((((a % 100) or (a // 100)) % 4) < 1))
# print((a % 100), (a // 100), (a % 100) or (a // 100), sep='\n')


'''
테스트 문제
1 ~ 2의 63 제곱 사이에 존재하는 임의의 자연수를 입력 받고, 그 수가 2의 제곱수에 해당하는지 판단하세요.
a > 0 and a == (a & (~(a - 1)))
-1 = 1 의 2진수 비트반전 + 0001 = 1110 + 0001 = 1111

예시 1)
a = 0 = 0000
a > 0 = False
a - 1 = 0000 + 1111 = 1111
~1111 = 0000 + 0001 = 0001
(a & (~(a - 1))) = 0000 & 0001 = 0000
a == (a & (~(a - 1))) = 0000 == 0000 = True

예시 2)
a = 1 = 0001
a > 0 = True
a - 1 = 0001 + 1111 = 0001 0000 = 0000
~0000 = 1111 + 0001 = 0001 0000 = 0000
(a & (~(a - 1))) = 0001 & 0000 = 0000
a == (a & (~(a - 1))) = 0001 == 0000 = False

예시 3)
a = 2 = 0010
a > 0 = True
a - 1 = 0010 + 1111 = 0001 0001 = 0001
~0001 = 1110 + 0001 = 0000 1111 = 1111
(a & (~(a - 1))) = 0001 & 1111 = 0001
a == (a & (~(a - 1))) = 0001 == 0001 = True

예시 4)
a = 3 = 0011
a > 0 = True
a - 1 = 0011 + 1111 = 0001 0010 = 0010
~0010 = 1101 + 0001 = 0000 1110 = 1110
(a & (~(a - 1))) = 0011 & 1110 = 0010
a == (a & (~(a - 1))) = 0011 == 0010 = False

예시 5)
a = 4 = 0100
a > 0 = True
a - 1 = 0100 + 1111 = 0001 0011 = 0011
~0011 = 1100 + 0001 = 0000 1101 = 1101
(a & (~(a - 1))) = 0100 & 1101 = 0100
a == (a & (~(a - 1))) = 0100 == 0100 = True

예시 6)
a = 6 = 0110
a > 0 = True
a - 1 = 0110 + 1111 = 0001 0101 = 0101
~0101 = 1010 + 0001 = 0000 1011 = 1011
(a & (~(a - 1))) = 0110 & 1011 = 0010
a == (a & (~(a - 1))) = 0110 == 0010 = False

예시 7)
a = 8 = 1000
a > 0 = True
a - 1 = 1000 + 1111 = 0001 0111 = 0111
~0111 = 1000 + 0001 = 0000 1001 = 1001
(a & (~(a - 1))) = 1000 & 1001 = 1000
a == (a & (~(a - 1))) = 1000 == 1000 = True
'''
# 정답 1
# a = int(input())
# for n in range(1, 64):
#     chk = 2 ** n
#     if a == chk:
#         print('{} 은(는) 2의 제곱수입니다.'.format(a))
#         break
# else:
#     print('{} 은(는) 2의 제곱수가 아닙니다.'.format(a))
    
# 정답 2
# a = int(input())
# print(a == (a & (~(a - 1))))



'''
좌표축과 (x, y) 평행한 직사각형엔 4개의 점이 있습니다.
이 중 하나의 점의 (p) 좌표가 비공개되어 있을때, 
나머지 3개의 점의 (a, b, c) 좌표를 이용해서 점의 (p) 좌표를 구하는 프로그램을 개발하세요.

정사각형이므로 동일한 x 값과 y 값이 2개씩 존재함
1개씩 존재하는 x 값과 y 값의 좌표가 정답임
'''
import pprint
# 문제
p_list = {
    'a':{'x':3, 'y':4},
    'b':{'x':3, 'y':8},
    'c':{'x':12, 'y':4},
}
p_answer = {}

# 정답 1
# if p_list['a']['x'] == p_list['b']['x']:
#     p_answer['x'] = p_list['c']['x']
# elif p_list['a']['x'] == p_list['c']['x']:
#     p_answer['x'] = p_list['b']['x']
# else:
#     p_answer['x'] = p_list['a']['x']
    
# if p_list['a']['y'] == p_list['b']['y']:
#     p_answer['y'] = p_list['c']['y']
# elif p_list['a']['y'] == p_list['c']['y']:
#     p_answer['y'] = p_list['b']['y']
# else:
#     p_answer['y'] = p_list['a']['y']
    
# pprint.pprint(p_answer)

# 정답 2
# p_answer['x'] = p_list['a']['x'] ^ p_list['b']['x'] ^ p_list['c']['x']
# p_answer['y'] = p_list['a']['y'] ^ p_list['b']['y'] ^ p_list['c']['y']
# pprint.pprint(p_answer)